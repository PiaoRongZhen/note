### Alice的借条
假设Alice需要向Bob借100万元。
通过银行汇款，Alice可以立刻从Bob那里收到钱。
Alice用电子邮件来发送借条。
“Bob，我向你借款100万元。——Alice”
Alice写的邮件有可能被**篡改**，也有可能是有人**伪装**成Alice发送了这封邮件，或者Alice也可以事后以“我不知道这张借条”为理由来进行**否认**。

使用数字签名可以识别篡改和伪装，还可以防止否认。
### 签名的生成和验证
在数字签名技术中，出现了下面两种行为。
* 生成消息签名的行为
* 验证消息签名的行为

生成消息签名这一行为是由消息的发送者Alice来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值。
验证数字签名这一行为一般是由消息的接收者Bob来完成的，但也可以由需要验证消息的第三方来完成。验证签名就是检查该消息的签名是否真的属于Alice。

在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。
数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。
签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。

### 公钥密码与数字签名
数字签名就是通过将公钥密码“反过来用”而实现的。
用私钥加密相当于生成签名
用公钥解密相当于验证签名
用公钥加密所得到的密文，只能用与该公钥配对的私钥才能解密；同样地，用私钥加密所得到的密文，也只能用与该私钥配对的公钥才能解密。也就是说，如果用某个公钥成功解密了密文，那么就能够证明这段密文是用与该公钥配对的私钥进行加密所得到的。

用私钥进行加密这一行为只能由持有私钥的人完成，正是基于这一事实，我们才可以将用私钥加密的密文作为签名来对待。
由于公钥是对外公开的，因此任何人都能够用公钥进行解密，这就产生了一个很大的好处，即任何人都能够对签名进行验证。
### 数字签名的方法
对消息签名非常耗时，于是我们对消息的散列值签名。（公钥密码算法慢）
1. Alice用单向散列函数计算消息的散列值。
2. Alice用自己的私钥对散列值进行加密。
3. Alice将消息和签名发送给Bob。
4. Bob用Alice的公钥对收到的签名进行解密。
5. Bob将签名解密后得到的散列值与Alice直接发送的消息的散列值进行对比。(如果两者一致，则签名验证成功)


### 通过RSA实现数字签名
**用RSA生成签名**
$$签名=消息^D\ mod\ N$$
D和N就是签名者的私钥。
**用RSA验证签名**
$$由签名求得的消息=签名^E\ mod\ N$$
E和N就是签名者的公钥。

